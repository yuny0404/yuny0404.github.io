---

layout: post
title: 10844 쉬운 계단 수
categories: 알고리즘
tags: [백준,알고리즘,C]
---

### 문제

45656이란 수를 보자.

이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.

#### 입력

첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

#### 출력

첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

#### 예제입력1

```
1
```

#### 예제출력1

```
9
```

#### 예제입력2

```
2
```

#### 예제출력2

```
17
```

### 풀이

입력이 1일때 부터 차례로 보자.

|  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |

다른 경우 없이 각 수인 9개 밖에 없다.

다음은 2인 경우를 보자.  

2 이상의 경우에 앞자리가 0인 경우를 제외한다. 

|  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
|  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |      |





### 코드

```
#include <stdio.h>

int d[101][10] = { 0,};

int func(int n)
{	
	int i,j;
	if(n == 1)
		return 9;
	else
	{
		for(i = 1; i < 10; i++)
			d[1][i] = 1;
		for(i = 2; i<= n; i++)
		{
			for(j = 0; j < 10; j++)
			{			
				if(j == 0)
					d[i][j] = d[i-1][1];
				else if(j == 9)
					d[i][j] = d[i-1][8];	
				else
					d[i][j] = (d[i - 1][j - 1] + d[i - 1][j + 1]) % 1000000000;
			}
		}
		long long int ans = 0;
		for(i = 0; i<= 9; i++)
			ans += d[n][i];
		return ans %= 1000000000;
	}
}

int main()
{
	int n;
	scanf("%d",&n);
	printf("%d",func(n));
}

```

